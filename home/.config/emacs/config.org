#+TITLE: Arjan's Emacs configuration
#+STARTUP: overview
#+OPTIONS: html-style:nil html-scripts:nil html-preamble:nil html-postamble:nil author:nil
#+HTML_HEAD: <link rel="stylesheet" href="style.css">

* Introduction

We'll make Emacs our own by configuring our personal details.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Arjan van der Gaag")
(setq user-mail-address "arjan@arjanvandergaag.nl")
#+END_SRC

Let's announce that we are now starting to process the personal configuration file. This might help with debugging, especially when Emacs is slow to start.

#+BEGIN_SRC emacs-lisp
(message "[avdg] Starging up, stand by...")
#+END_SRC

* Start-up optimizations

If we're not careful, Emacs might get slow to start, loading tons of packages and customizations. To ensure Emacs remains acceptably fast to load, we use a few optimizations when launching Emacs, and in configuring our packages.

First, ensure we always load the newest code we have.

#+BEGIN_SRC emacs-lisp
(setq load-prefer-newer t)
#+END_SRC

** Garbage collection

As we launch Emacs we load a lot of code. We "disable" garbage collection, so we use more memory but are done faster. Once we're done, we restore the garbage collection threshold back to 16Mb.

#+BEGIN_SRC emacs-lisp
(setq avdg-gc-cons-threshold 16777216)
(setq gc-cons-threshold most-positive-fixnum)
(setq gc-cons-percentage 0.6)

(add-hook 'emacs-startup-hook
          (lambda () (setq gc-cons-threshold 16777216
                           gc-cons-percentage 0.1)))
#+END_SRC

Trick from Doom Emacs: we "disable" GC in the minibuffer, so it won't slow down expensive commands, like completion frameworks.

#+BEGIN_SRC emacs-lisp
(defun avdg/defer-garbage-collection-h ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun avdg/restore-garbage-collection-h ()
  (run-at-time
   1 nil (lambda () (setq gc-cons-threshold avdg-gc-cons-threshold))))

(add-hook 'minibuffer-setup-hook #'avdg/defer-garbage-collection-h)
(add-hook 'minibuffer-exit-hook #'avdg/restore-garbage-collection-h)
#+END_SRC

** The start-up screen

We further give Emacs less work to do by inhibiting some start-up screen behaviour, and launching in =fundamental-mode=, which is as simple as it gets.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
(setq inhibit-startup-echo-area-message user-login-name)
(setq inhibit-default-init t)
(setq initial-scratch-message nil)
(setq initial-major-mode 'fundamental-mode)
#+END_SRC

Remove "For information about GNU Emacs..." message.

#+BEGIN_SRC emacs-lisp
(advice-add #'display-startup-echo-area-message :override #'ignore)
#+END_SRC

** Emacs server

Always make sure to start the server mode, so we can use =emacsclient=.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook
    (lambda ()
      (require 'server)
      (unless (server-running-p)
        (server-start))))
#+END_SRC

* Package setup

Emacs is powerful enough on its own, but it really shines when we extend it with external packages. For that, we use the built-in =package.el= package management system, which we need to set up first.

** Package sources

First, we want to register [[https://melpa.org/#/][Melpa]] as a package source because it is the most up-to-date and complete package repository. We also add [[http://elpa.gnu.org][Elpa]], the "standard" Emacs package repository. Finally, we also add the special package repository for [[https://orgmode.org][Org-mode]], so we can later on install its latest version, rather than sticking with what shipped with Emacs itself.

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))
#+END_SRC

** Initializing the package system

When we launch Emacs, we initialize the package system and check if we need to fetch a package archive. If we have no package information on our system yet, we fetch it. This should only be done once.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
#+END_SRC

** Installing use-package

The one package we need to manually install at this point is [[https://github.com/jwiegley/use-package][use-package]] as it will handle installing and lazy-loading other packages for us.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

* General utilities

** Quickly edit our configuration

Emacs is a text editor meant to be customized and hacked on. To that end, it is important that it is easy to edit the personal configuration. We define a function to edit the "real" initialisation file:

#+BEGIN_SRC emacs-lisp
(defun avdg/reload-emacs-configuration ()
  (interactive)
  (load-file (concat user-emacs-directory "init.el")))
#+END_SRC

And one to edit our personal literal configuration:

#+BEGIN_SRC emacs-lisp
(defun avdg/edit-config ()
  (interactive)
  (find-file (concat user-emacs-directory "config.org")))
#+END_SRC

** Set up environment

I mainly use Emacs on Mac OS, which has its own peculiar way of launching applications. That means that applications like Emacs, when started as a GUI application, does not have the same environment as one would see in a shell

To counter this and ensure Emacs has access to the same environment variables as a shell would have, we generate an =env= file with the default environment variables that we read on start-up. This way, we don't have to use something like [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]to launch a new shell just to read its environment -- although we /do/ have to manually maintain the env file.

To create the =env= file, you can do this in a shell:

#+begin_src sh
env > ~/.config/emacs/env
#+end_src

We then define a function to read that file, parse its contents and add it to Emacs own environment configuration.

#+BEGIN_SRC emacs-lisp
(defun avdg/load-envvars-file (file)
  "Read and set envvars from FILE."
  (if (null (file-exists-p file))
      (signal 'file-error (list "No envvar file exists" file))
    (when-let
        (env
         (with-temp-buffer
           (save-excursion
             (setq-local coding-system-for-read 'utf-8)
             (insert "\0\n")
             (insert-file-contents file))
           (save-match-data
             (when (re-search-forward "\n *\\([^#= \n]*\\)=" nil t)
               (setq
                env (split-string (buffer-substring (match-beginning 1) (point-max))
                                  "\n"
                                  'omit-nulls))))))
      (setq-default process-environment
                    (append (nreverse env)
                            (default-value 'process-environment))
                    exec-path
                    (append (split-string (getenv "PATH") path-separator t)
                            (list exec-directory))
                    shell-file-name
                    (or (getenv "SHELL")
                        (default-value 'shell-file-name)))
      env)))
#+END_SRC

Finally, we call that function when necessary.

#+BEGIN_SRC emacs-lisp
(if (or (display-graphic-p)
        (daemonp))
    (avdg/load-envvars-file (expand-file-name "env" user-emacs-directory)))
#+END_SRC

* General defaults

Emacs can be great, but it isn't out of the box. We'll need to configure some sane defaults.

** File handling

Warn before opening /very/ large files (100mb+).

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 104857600)
#+END_SRC

Automatically reload files from disk when they've changed.

#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :hook (after-init . global-auto-revert-mode)
  :diminish auto-revert-mode
  :init
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil))
#+END_SRC

When dealing with symlinks, use the original file and don't bother us about it.

#+BEGIN_SRC emacs-lisp
(setq find-file-visit-truename t)
(setq vc-follow-symlinks t)
(setq find-file-suppress-same-file-warnings t)
#+END_SRC

** Backups

Make sure Emacs does not keep backup files around alongside their originals, but in a dedicated location. Do not remove old versions, but keep them around with version numbers.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
#+END_SRC

Also store away auto-save files:

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms `((".*" ,(concat user-emacs-directory "auto-save-list/") t)))
#+END_SRC

** Minibuffer

Allow nested minibuffers.

#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
#+END_SRC

Show the current key sequence in the minibuffer.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.02)
#+END_SRC

Allow the minibuffer to grow, up to a point.

#+BEGIN_SRC emacs-lisp
(setq resize-mini-windows 'grow-only)
(setq max-mini-window-height 0.15)
#+END_SRC

Save minibuffer history using =savehist-mode=.

#+BEGIN_SRC emacs-lisp
(setq savehist-file (concat user-emacs-directory "savehist"))
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(savehist-mode 1)
#+END_SRC

** Window configuration

Clean up the window and frame by removing some chrome we don't need.

#+BEGIN_SRC emacs-lisp
(setq indicate-buffer-boundaries nil)
(setq indicate-empty-lines nil)
(setq tool-bar-mode nil)
(setq menu-bar-mode nil)
(setq scroll-bar-mode nil)
#+END_SRC

Further tweak how frames and windows are displayed.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("%b"))
(setq icon-title-format frame-title-format)
(setq window-resize-pixelwise t)
(setq frame-resize-pixelwise t)
(setq window-divider-default-places t)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-right-width 1)
(setq truncate-partial-width-windows nil)
(window-divider-mode 1)
#+END_SRC

When making splits, favour vertical splits.

#+BEGIN_SRC emacs-lisp
(setq split-width-threshold 160)
(setq split-height-threshold nil)
#+END_SRC

Use the built-in =winner-mode= to undo and redo changes in window configuration.

#+begin_src emacs-lisp
(use-package winner
  :ensure f
  :config
  (winner-mode 1))
#+end_src

** General editing

Sentences should never be followed by multiple spaces.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Behave like other modern editors and replace the selection when typing over it.

#+BEGIN_SRC emacs-lisp
(setq delete-selection-mode t)
#+END_SRC

Try to use UTF-8 when possible.

#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
#+END_SRC

Use smart tab behaviour: either indent or complete.

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
#+END_SRC

** Spell checking

Enable spell checking with Flyspell using =aspell=, which must be installed externally. For example, install it with Homebrew:

#+begin_src sh
brew install aspell
#+end_src

We enable =flyspell-mode= in text modes, while using =flyspell-prog-mode= in programming modes.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure f
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode))
  :init
  (setq ispell-program-name "aspell")
  (setq ispell-extra-args '("--sug-mode=ultra" "--run-together"))
  (setq flyspell-issue-welcome-flag nil)
  (setq flyspell-issue-message-flag nil)
  :config
  (require 'ispell))
#+END_SRC

** Theme

Use the [[https://github.com/hlissner/emacs-doom-themes][Doom One theme]].

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t)
  (setq doom-themes-enable-italic t)
  (load-theme 'doom-one t)
  (doom-themes-visual-bell-config)
  (doom-themes-org-config))
#+END_SRC

** Search

Use case-insensitive search.

#+BEGIN_SRC emacs-lisp
(setq case-fold-search t)
#+END_SRC

** User interface

*** Modeline

Use [[https://github.com/seagle0128/doom-modeline][the modeline that comes with Doom Emacs]] because it's light-weight but useful.

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode))
#+END_SRC

*** Working with buffers

Ibuffer presents a rich listing of open buffers with support for filtering, grouping and batch operations. We define an extra column for human-readable filesize.

#+begin_src emacs-lisp
(use-package ibuffer
  :ensure f
  :init
  (setq-default ibuffer-show-empty-filter-groups nil)
  :config
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (file-size-human-readable (buffer-size))))
#+end_src

Also group buffers by project root using [[https://github.com/purcell/ibuffer-projectile/tree/ecbe482804a217b1471593f6c7a8b3d64f3cdc47][ibuffer-projectile]].

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-projectile
  :hook (ibuffer . ibuffer-projectile-set-filter-groups))
#+END_SRC

Name buffers using the last few parts of their paths.

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :ensure f
  :init
  (setq uniquify-buffer-name-style 'forward
        uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

Show up to 30 buffers in the buffers menu.

#+BEGIN_SRC emacs-lisp
(setq buffers-menu-max-size 30)
#+END_SRC

*** Reduce annoyances

No need to type =yes= where =y= will do.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

No need to constantly confirm everything.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs nil)
(setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

...or to use GUI dialog boxes.

#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil)
(setq use-dialog-box nil)
#+END_SRC

Reduce annoyances.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
(setq visible-bell nil)
(setq blink-matching-paren nil)
(setq x-stretch-cursor nil)
#+END_SRC

*** Other tweaks

Allow purging of displayed minor modes. This helps keep the modeline clean.

#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

Slow down updates just a little.

#+BEGIN_SRC emacs-lisp
(setq idle-update-delay 1.0)
#+END_SRC

Optimise scrolling and resizing.

#+BEGIN_SRC emacs-lisp
(setq fast-but-imprecise-scrolling t)
(setq frame-inhibit-implied-resize t)
(setq hscroll-margin 2)
(setq hscroll-step 1)
(setq scroll-conservatively 101)
(setq scroll-margin 0)
(setq scroll-preserve-screen-position t)
(setq auto-window-vscroll nil)
(setq mouse-wheel-scroll-amount '(5 ((shift) . 2)))
(setq mouse-wheel-progressive-speed nil)
#+END_SRC

Reduce work by not rendering cursors or regions in non-focused windows.

#+BEGIN_SRC emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
(setq highlight-nonselected-windows nil)
#+END_SRC

** Text and fonts

Use SF Mono as base font.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "SF Mono-13" :height 120)
(set-face-attribute 'fixed-pitch nil :font "SF Mono-13" :height 1.0)
#+END_SRC

Also tweak the variable pitch font in case we are working with text where fixed-width fonts don't make as much sense.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'variable-pitch nil :font "New York-16" :height 1.1)
#+END_SRC

We usually want to use the variable-pitch fonts in org-mode documents:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+END_SRC

Although variable-width fonts are great for prose, org-mode code blocks should be rendered in fixed-width fonts.

#+BEGIN_SRC emacs-lisp
(custom-theme-set-faces
   'user
   '(org-block ((t (:inherit fixed-pitch))))
   '(org-block-begin-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-block-end-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-code ((t (:inherit (shadow fixed-pitch)))))
   '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
   '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-table ((t (:inherit fixed-pitch))))
   '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
#+END_SRC

Provide decent underlining.

#+BEGIN_SRC emacs-lisp
(setq x-underline-at-descent-line t)
#+END_SRC

There are keybindings for scaling the text size per buffer defined further below.

* Navigation

** Tabs

Use =tab-bar-mode= and the =emacs-mac= build to show frame-level tabs. This uses the command key on the mac to allow selecting tabs by number (=cmd-1=, =cmd-2=, etc.). Further keybindings are further below.

#+BEGIN_SRC emacs-lisp
(use-package tab-bar
  :ensure f
  :hook (after-init . tab-bar-mode)
  :init
  (setq tab-bar-select-tab-modifiers '(super)
        tab-bar-new-tab-choice "*scratch*"
        tab-bar-new-button-show nil
        tab-bar-tab-hints t
        tab-bar-close-tab-select 'recent
        tab-bar-close-button nil))
#+END_SRC

** Recent files

Track recently used files.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :ensure f
  :init
  (setq recentf-max-saved-items 200)
  (setq recentf-max-menu-items 10)
  (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory))
  (setq recentf-auto-cleanup 'never)
  :config
  (recentf-mode 1))
#+END_SRC

** Dired

Dired is Emacs' built-in file navigator. Customize =dired= and autoload on =dired-jump=.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure f
  :commands dired-jump
  :init
  (setq dired-auto-revert-buffer t)
  (setq dired-dwim-target t)
  (setq dired-hide-details-hide-symlink-targets nil)
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'top)
  (setq dired-listing-switches "-aBhl --group-directories-first")
  :config
  (when (string= system-type "darwin")
    (setq dired-use-ls-dired t)
    (setq insert-directory-program "/usr/local/bin/gls")))
#+END_SRC

Use =diredfl= to provide extra font locking rules for Dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :hook (dired-mode . diredfl-mode))
#+END_SRC

Use Emacs' own =dired-x= for extra Dired features.

#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :ensure f
  :hook (dired-mode . dired-omit-mode)
  :config
  (setq dired-omit-verbose nil)
  (setq dired-omit-files (concat dired-omit-files
                              "\\|^.DS_Store\\'"
                              "\\|^.projectile\\'"
                              "\\|^.git\\'"))
  (setq dired-clean-confirm-killing-deleted-buffers nil))
#+END_SRC

Use =fd-dired= to use =fd= for fast directory listings.

#+BEGIN_SRC emacs-lisp
(use-package fd-dired
  :defer t
  :init
  (global-set-key [remap find-dired] #'fd-dired))
#+END_SRC

* Development
** Whitespace

Use sensible defaults for whitespace.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default tab-always-indent nil)
(setq-default fill-column 80)
(setq-default word-wrap t)
(setq-default truncate-lines t)
#+END_SRC

Indicate our location in a buffer in the modeline.

#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
(size-indication-mode t)
#+END_SRC

Finally, some special dealings for whitespace.

#+BEGIN_SRC emacs-lisp
(setq whitespace-line-column nil)
(setq require-final-newline t)
(setq whitespace-style '(face indentation tabs tab-mark spaces space-mark newline newline-mark trailing lines-tail))
(setq whitespace-display-mappings '((tab-mark ?\t [?› ?\t])
                                    (newline-mark ?\n [?¬ ?\n])
                                    (space-mark ?\  [?·] [?.])))
#+END_SRC

For the rest, use =ws-butler=. It will handle stripping trailing whitespace for us.

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :diminish ws-butler-mode
  :hook (after-init . ws-butler-global-mode))
#+END_SRC

** Pairing characters

We want to automatically insert closing parantheses as we type. We do that with the built-in electric pair mode.

#+begin_src emacs-lisp
(use-package electric-pair
  :ensure f
  :diminish electric-pair-mode
  :hook (prog-mode . electric-pair-mode)
  :init
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit))
#+end_src

** Syntax

Highlight matching parentheses.

#+BEGIN_SRC emacs-lisp
(use-package paren
  :init
  (setq show-paren-delay 0.1)
  (setq show-paren-highlight-openparen t)
  (setq show-paren-when-point-inside-paren t)
  (setq show-paren-when-point-in-periphery t)
  :hook (after-init . show-paren-mode))
#+END_SRC

Use =visual-line-mode= in all text modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook #'visual-line-mode)
(diminish 'visual-line-mode)
#+END_SRC

Use line numbers in all programming-related modes.

#+BEGIN_SRC emacs-lisp
(setq-default display-line-numbers-width 3)
(setq-default display-line-numbers-widen t)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

** Compilation

#+BEGIN_SRC emacs-lisp
(setq-default compilation-scroll-output 'first-error)
(setq-default compilation-ask-about-save nil)
(setq-default compilation-always-kill t)
#+END_SRC

** Directory-specific environment

When using [[https://direnv.net][Direnv]] to manage directory-specific environment variables, we want Emacs to use the same variables as the shell would have when running commands from a terminal.

#+BEGIN_SRC emacs-lisp
(use-package direnv
  :config
  (direnv-mode))
#+END_SRC

** Other

Enable clickable URLs and e-mail addresses in programming modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'goto-address-prog-mode)
(setq goto-address-mail-face 'link)
#+END_SRC

Automatically make script files executable on save.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

* MacOS compatibility

Since I mostly use Emacs on MacOS in GUI mode, rather than in a terminal, it makes sense it make it blend in with other, more "traditional" applications.

** Modifier keys

Set up sensible modifier keys.

#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'super)
(setq mac-option-modifier 'meta)
(setq ns-command-modifier 'super)
(setq ns-option-modifier 'meta)
(setq ns-right-option-modifier 'none)
#+END_SRC

** System integration

Use Spotlight to locate.

#+BEGIN_SRC emacs-lisp
(setq locate-command "mdfind")
#+END_SRC

Use native full-screen but do not create new frames when opening files.

#+BEGIN_SRC emacs-lisp
(setq ns-use-native-fullscreen t)
(setq ns-pop-up-frames nil)
#+END_SRC

Enable emoji, and stop the UI from freezing when trying to display them.

#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-fontset-font)
  (set-fontset-font t 'unicode "Apple Color Emoji" nil 'prepend))
#+END_SRC

Blend in frames in MacOS keeping appearance and text color aligned.

#+BEGIN_SRC emacs-lisp
(use-package ns-auto-titlebar)
#+END_SRC

Delete files to trash on macOS, as an extra layer of precaution against accidentally deleting wanted files.

#+BEGIN_SRC emacs-lisp
(use-package osx-trash
  :diminish
  :commands osx-trash-move-file-to-trash
  :init
  (setq delete-by-moving-to-trash t))
#+END_SRC

** Mimick native MacOS keybindings

Window hiding and toggling:

#+begin_src emacs-lisp
(global-set-key (kbd "M-`") 'ns-next-frame)
(global-set-key (kbd "M-h") 'ns-do-hide-emacs)
(global-set-key (kbd "M-ˍ") 'ns-do-hide-others)
(global-set-key (kbd "s-F") 'toggle-frame-fullscreen)
(global-set-key (kbd "s-m") 'suspend-frame)
#+end_src

Selecting, copying and pasting:

#+begin_src emacs-lisp
(global-set-key (kbd "s-a") 'mark-whole-buffer)
(global-set-key (kbd "s-v") 'yank)
(global-set-key (kbd "s-c") 'kill-ring-save)
#+end_src

Working with tabs:

#+begin_src emacs-lisp
(global-set-key (kbd "s-t") 'tab-bar-new-tab)
(global-set-key (kbd "s-{") 'tab-bar-switch-to-next-tab)
(global-set-key (kbd "s-}") 'tab-bar-switch-to-prev-tab)
(global-set-key (kbd "s-w") 'tab-bar-close-tab)
#+end_src

Dealing with font size:

#+begin_src emacs-lisp
(global-set-key (kbd "s--") 'text-scale-decrease)
(global-set-key (kbd "s-+") 'text-scale-increase)
(global-set-key (kbd "s-=") (lambda () (interactive) (text-scale-increase 0)))
#+end_src

Others:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-s") 'save-buffer)
(global-set-key (kbd "s-l") 'goto-line)
(global-set-key (kbd "s-z") 'undo)
(global-set-key (kbd "s-q") 'save-buffers-kill-emacs)
(global-set-key (kbd "s-f") 'swiper-isearch)
(global-set-key (kbd "s-,") 'customize)
#+END_SRC

* Dedicated layers

** Evil

Emacs is a great operating system only lacking a good text editor. Using [[https://github.com/emacs-evil/evil][Evil]]  gives us the power of Vim text editing within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-keybinding nil)
  (setq evil-symbol-word-search t)
  (setq evil-shift-width 2)
  (setq evil-respect-visual-line-mode t)
  (setq evil-want-visual-char-semi-exclusive t)
  (setq evil-ex-search-vim-style-regexp t)
  (setq evil-ex-visual-char-range t)
  (setq evil-normal-state-cursor 'box)
  (setq evil-insert-state-cursor 'bar)
  (setq evil-visual-state-cursor 'hollow)
  (setq evil-ex-interactive-search-highlight 'selected-window)
  (setq evil-kbd-macro-suppress-motion-error t)
  (setq evil-undo-system 'undo-redo)
  (setq evil-mode-line-format 'nil)
  :config
  (evil-mode 1)
  (evil-select-search-module 'evil-search-module 'evil-search))
#+END_SRC

For further integration with other common Emacs modes, we use =evil-collection=.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+END_SRC

Surround is an indispensable Vim plugin, so we also its Emacs equivalent [[https://github.com/emacs-evil/evil-surround][evil-surround]].

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+END_SRC

I like Vim's ability to increment/decrement numbers, so we replicate that here too with [[https://github.com/cofi/evil-numbers][evil-numbers]].

#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :after evil)
#+END_SRC

[[https://github.com/TheBB/evil-indent-plus][Evil-indent-plus]] allows us to treat blocks of text at the same indentation as a text object.

#+BEGIN_SRC emacs-lisp
(use-package evil-indent-plus
  :after evil
  :config
  (evil-indent-plus-default-bindings))
#+END_SRC

With [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] we can quickly comment or uncomment blocks of text.

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :commands (evilnc-comment-operator
             evilnc-inner-comment
             evilnc-outer-commenter))
#+END_SRC

Since in Vim, =Esc= will get you out of pretty much anything (much like =C-g= in Emacs), we want to have the same behaviour in Emacs.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC

** Keybindings

To make it easier to learn our keybindings we use the which-key package which will show us a popup with available suffices.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :init
  (setq which-key-idle-delay 1)
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

We use the general package to define our keybindings.

#+BEGIN_SRC emacs-lisp
(use-package general)
#+END_SRC

For convenience, we define two helper functions to define leader and local leader keybindings.

#+BEGIN_SRC emacs-lisp
(general-create-definer avdg-leader-def
  :prefix "SPC")
(general-create-definer avdg-local-leader-def
  :prefix "SPC m")
#+END_SRC

The leader keys are used as the primary grouping mechanism as seen in Spacemacs and Doom Emacs. We try to use keys for groups that easy to remember

#+BEGIN_SRC emacs-lisp
(avdg-leader-def
  :keymaps 'normal
  "p" '(:keymap projectile-command-map :package projectile :which-key "Projectile")
  "w" '(:keymap evil-window-map :package evil :which-key "Window")
  "h" '(:keymap help-map :which-key "Help")
  "c" '(:ignore t :which-key "Code")
  "g" '(:ignore t :which-key "Magit")
  "f" '(:ignore t :which-key "File")
  "b" '(:ignore t :which-key "Buffer")
  "m" '(:ignore t :which-key "Major mode")
  "o" '(:ignore t :which-key "Open")
  "t" '(:ignore t :which-key "Toggle")
  "s" '(:ignore t :which-key "Search"))
#+END_SRC

There are a few special leader keybindings that do not lead to sub-groups of keybindings, but immediately invoke an action.

#+BEGIN_SRC emacs-lisp
(avdg-leader-def
  :keymaps 'normal
  ";" '(pp-eval-expression :which-key "Eval expression")
  ":" '(execute-extended-command :which-key "M-x")
  "u" '(universal-argument :which-key "Universal arg")
  "." '(find-file :which-key "Find file")
  "," '(switch-to-buffer :which-key "Switch to buffer")
  "SPC" '(projectile-find-file :which-key "Find in project")
  "X" '(org-capture :which-key "Org capture"))
#+END_SRC

The ~SPC w~ prefix is used for window-related functions. We mostly use Evil's keybindings here, but we do add a few custom bindings, such as those for =winner-mode=.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC w"
  :keymaps 'normal
  "d" '(evil-quit :which-key "Close window")
  "u" '(winner-undo :which-key "Undo window change")
  "U" '(winner-redo :which-key "Redo window change"))
#+END_SRC

The ~SPC t~ prefix is used for toggling functions.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC t"
  :keymaps 'normal
  "w" '(toggle-truncate-lines :which-key "Word wrap")
  "l" '(display-line-numbers-mode :which-key "Line numbers")
  "c" '(display-fill-column-indicator-mode :which-key "Fill column")
  "r" '(read-only-mode :which-key "Read only")
  "s" '(flyspell-mode :which-key "Spell checking")
  "f" '(flycheck-mode :which-key "Flycheck")
  "F" '(toggle-frame-fullscreen :which-key "Fullscreen"))
#+END_SRC

The ~SPC o~ prefix is used for functions opening things.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC o"
  :keymaps 'normal
  "-" '(dired-jump :which-key "Dired")
  "_" '(dired-jump-other-window :which-key "Dired other window")
  "f" '(make-frame :which-key "New frame")
  "i" '(lsp-ui-imenu :which-key "Symbols sidebar"))
#+END_SRC

The ~SPC f~ prefix is used for file-related functions.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC f"
  :keymaps 'normal
  "f" '(find-file :which-key "Find file")
  "d" '(counsel-dired-jump :which-key "Find directory")
  "r" '(counsel-recentf :which-key "Recent files"))
#+END_SRC

The ~SPC b~ prefix is used for buffer-related functions.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC b"
  :keymaps 'normal
  "b" '(switch-to-buffer :which-key "Switch buffer")
  "i" '(ibuffer :which-key "Ibuffer")
  "d" '(kill-current-buffer :which-key "Kill buffer")
  "r" '(revert-buffer :which-key "Revert buffer"))
#+END_SRC

The ~SPC c~ prefix is used for code-related functions. As a secondary grouping, ~c~ can also stand for "configuration", as the functions to quickly open and reload the Emacs configuration are also here.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC c"
  :keymaps 'normal
  "e" '(avdg/edit-config :which-key "Edit config.org")
  "f" '(lsp-ivy-workspace-symbol :which-key "Workspace symbol")
  "d" '(lsp-find-definition :which-key "Go to definition")
  "D" '(lsp-ui-peek-find-references :which-key "Peek references")
  "r" '(avdg/reload-emacs-configuration :which-key "Reload config.org"))
#+END_SRC

Finally, there are a few extra keybindings to match Evil's keybindings scheme in the spirit of Tim Pope's Unimpaired plugin, using the bracket keys as prefix for quickly navigating between topics.

#+BEGIN_SRC emacs-lisp
(general-def
  'normal
  "[x" 'next-error
  "]x" 'previous-error)
#+END_SRC

** Snippets

We use [[https://github.com/joaotavora/yasnippet][yasnippet]] to handle templating.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :commands (yas-minor-mode-on
             yas-expand
             yas-expand-snippet
             yas-lookup-snippet
             yas-insert-snippet
             yas-new-snippet
             yas-visit-snippet-file
             yas-activate-extra-mode
             yas-deactivate-extra-mode)
  :hook ((text-mode
          prog-mode
          conf-mode
          snippet-mode) . yas-minor-mode-on)
  :init
  (setq yas-snippet-dir '((concat user-emacs-directory "snippets")))
  :config
  (yas-reload-all)
  (general-def
    :prefix "SPC c"
    :keymaps 'normal
    "s" '(:ignore t :which-key "Snippets"))
  (general-def
    :prefix "SPC c s"
    :keymaps 'normal
    "e" '(yas-visit-snippet-file :which-key "Edit snippet")
    "i" '(yas-insert-snippet :which-key "Insert snippet")
    "t" '(yas-tryout-snippet :which-key "Try out snippet")
    "r" '(yas-reload-all :which-key "Reload snippets")
    "n" '(yas-new-snippet :which-key "New snippet")))
#+END_SRC

** LSP

LSP (Language Server Protocal) is a way for text editors to provide IDE-like features using a shared protocol that can be implemented for different languages. We use LSP where possible to make for a rich code editing environment in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
#+END_SRC

With hooks we determine where we want to use LSP mode. More languages can be added here.

#+BEGIN_SRC emacs-lisp
  :hook ((lsp-mode . lsp-enable-which-key-integration)
         (ruby-mode . lsp))
#+END_SRC

The configuration settings disable some of the more invasive features of LSP-mode.

#+BEGIN_SRC emacs-lisp
  :init
  (setq lsp-enable-folding nil)
  (setq lsp-enable-text-document-color nil)
  (setq lsp-enable-on-type-formatting nil)
#+END_SRC

LSP provides a useful global keybinding for jumping to a definition that we bind to Emacs' default =M-.=.

#+BEGIN_SRC emacs-lisp
  :bind ("M-." . lsp-find-definition))
#+END_SRC

Finally we use the extra packages =lsp-ui= and =lsp-ivy= for further integration.

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :commands lsp-ui-mode
  :init
  (setq lsp-ui-doc-enable nil)
  (setq lsp-ivy-workspace-symbol nil)
  (setq lsp-headerline-breadcrumb-enable nil)
  (setq lsp-ui-imenu-window-width 25))

(use-package lsp-ivy
  :commands lsp-ivy-workspace-symbol lsp-ivy-workspace-symbol)
#+END_SRC

** Vterm

[[https://github.com/akermu/emacs-libvterm][Vterm]] is a fully-fledged terminal emulator inside GNU Emacs based on libvterm. It is fast.

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :commands vterm vterm-other-window
  :init
  (setq vterm-kill-buffer-on-exit t))
#+END_SRC

It is often useful to quickly jump in and out of terminal buffers, so we use [[https://github.com/jixiuf/vterm-toggle][vterm-toggle]] to toggle between the current buffer and a vterm term, creating one if it does not yet exist. A special custom function can be used to toggle a terminal buffer for the current project root directory, rather than than the default directory of the current buffer, as =vterm-toggle= does.

#+BEGIN_SRC emacs-lisp
(defun avdg/vterm-toggle-project ()
  "Toggle a vterm buffer in the project root."
  (interactive)
  (let ((default-directory (projectile-project-root)))
    (vterm-toggle-cd)))

(use-package vterm-toggle
  :commands vterm-toggle vterm-toggle-cd
  :init
  (global-set-key (kbd "s-±") 'vterm-toggle)
  (global-set-key (kbd "s-§") 'avdg/vterm-toggle-project))
#+END_SRC

** Avy

[[https://github.com/abo-abo/avy][Avy]] allows us to quickly jump to different points in a window. We set up ~gs~ as a keybinding to invoke it.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands avy-goto-char
  :init
  (setq avy-style 'at-full)
  (setq avy-background t)
  (setq avy-all-windows t)
  (general-def
    'normal
    "gs" #'avy-goto-char))
#+END_SRC

** Completion/selection

There are a lot of things in Emacs that benefit from having fuzzy-finding, autocompletion and interactive selection from a list of options. [[https://oremacs.com/swiper/][Ivy]] provides a framework to do that. It is simpler than Helm, easy to set up and tremendously useful.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :hook (after-init . ivy-mode)
  :diminish
  :init
  (setq ivy-sort-max-size 7500)
  (setq projectile-completion-system 'ivy)
  (setq ivy-use-selectable-prompt t)
  :config
  (general-def
    :prefix "SPC s"
    :keymaps 'normal
    "'" '(ivy-resume :which-key "Resume last search"))
  (ivy-mode 1))
#+END_SRC

Swiper comes with Ivy, along with Counsel, and offers a line-based replacement for Emacs own =isearch= functionality. It allows you to filter lines in the buffer matching a query.

Here, we just set up the relevant keybindings under the ~SPC s~ (for Search) group.

#+BEGIN_SRC emacs-lisp
(general-def
  :prefix "SPC s"
  :keymaps 'normal
  "s" '(swiper-isearch :which-key "Search")
  "i" '(counsel-imenu :which-key "Symbol")
  "b" '(swiper :which-key "Search buffer")
  "B" '(swiper-thing-at-point :which-key "Search buffer for thing at point")
  "a" '(swiper-all :which-key "Search all buffers")
  "A" '(swiper-all-thing-at-point :which-key "Search all buffers for thing at point"))
#+END_SRC

The default display of selection candidates in Ivy can be a bit sparse, so we use ivy-rich to enrich the display of candidates to include some more information.

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :after ivy
  :config
  (ivy-rich-mode 1))
#+END_SRC

Ivy on its own does not do much in Emacs yet, unless you set up your own keybindings. Counsel comes with Ivy and integrates Ivy into a lot of the default places in Emacs, such as finding files and =M-x=.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :after ivy
  :diminish
  :config
  (counsel-mode 1))
#+END_SRC

** File search

Ripgrep is the fastest search tool around and we integrate it with deadgrep. We bind it to ~SPC s /~.

#+BEGIN_SRC emacs-lisp
(use-package deadgrep
  :commands deadgrep
  :init
  (general-def
    :keymaps 'normal
    :prefix  "SPC s"
    "/" '(deadgrep :which-key "Deadgrep")))
#+END_SRC

Although we could use =projectile-ripgrep= to search a project, it requires the =ripgrep= package instead of =rg=. Instead, the get all the niceties of using Ivy and Counsel, we can use =counsel-rg=. For that, we provide custom search function that we will bind to =SPC-/=, that invokes =counsel-rg= from the context of a project root. This gives us a quick project-wide search function, with more advanced search functionality under =SPC s /= using =rg.el=.

#+BEGIN_SRC emacs-lisp
(defun avdg/ivy-file-search ()
  "Conduct a file search using ripgrep using."
  (interactive)
  (setq deactivate-mark t)
  (require 'counsel)
  (counsel-rg nil projectile-project-root))
(general-def
  :prefix "SPC"
  :keymaps 'normal
  "/" #'avdg/ivy-file-search)
#+END_SRC

** Flycheck

Use [[https://www.flycheck.org/en/latest/][flycheck]] for automatic linting of code buffers. Flycheck will delegate to checkers that are available on the system, which varies per language and perhaps per project.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :commands flycheck-list-errors flycheck-buffer
  :hook (after-init . global-flycheck-mode)
  :init
  (setq flycheck-check-syntax-automatically '(save mode-enabled idle-buffer-switch))
  (setq flycheck-display-errors-delay 0.25)
#+END_SRC

We bind listing the errors under ~SPC c~ (for Code).

#+BEGIN_SRC emacs-lisp
  :config
  (general-def
    :prefix "SPC c"
    :keymaps 'normal
    "x" '(flycheck-list-errors :which-key "Flycheck list errors")))
#+END_SRC

** Autocompletion

For in-buffer autocompletion we use [[http://company-mode.github.io][Company]].

#+BEGIN_SRC emacs-lisp
(use-package company
  :commands company-complete-common company-manual-begin company-grab-line
  :hook (after-init . global-company-mode)
  :diminish
  :init
  (setq company-require-match 'never)
  (setq company-global-modes '(not erc-mode message-mode help-mode gud-mode))
  (setq company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)))
#+END_SRC

For a slightly better front-end to Company we use [[https://github.com/sebastiencs/company-box][company-box]]:

#+begin_src emacs-lisp
(use-package company-box
  :hook (company-mode . company-box-mode))
#+end_src

** Git

We cannot use Emacs without using [[https://magit.vc][Magit]] as an interface to Git.

Some notes about configuration:

- =magit-revision-insert-related-refs=: don't display parent/related refs in commit buffers; they are rarely helpful and only add to runtime costs.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-file-delete
             magit-status
             magit-dispatch
             magit-status-here
             magit-branch-checkout
             magit-blame-addition
             magit-log)
  :init
#+END_SRC

We define some commonly used Git arguments to be the defaults:

#+BEGIN_SRC emacs-lisp
  (setq magit-fetch-arguments '("--prune"))
  (setq magit-merge-arguments '("--no-ff"))
  (setq magit-pull-arguments '("--rebase"))
  (setq magit-push-arguments '("--set-upstream"))
  (setq magit-log-arguments '("--graph" "--color" "--decorate" "-n256"))
#+END_SRC

And tweak further details:

#+BEGIN_SRC emacs-lisp
  (setq magit-save-repository-buffers nil)
  (setq magit-diff-refine-hunk t)
  (setq magit-revision-insert-related-refs nil)
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-repository-directories '(("~/code/" . 1)))
#+END_SRC

Finally, we define the Git-related functionality under ~SPC g~ (for Git).

#+BEGIN_SRC emacs-lisp
  (general-def
    :prefix "SPC g"
    :keymaps 'normal
    "/" '(magit-dispatch :which-key "Magit dispatch")
    "." '(magit-file-dispatch :which-key "Magit file dispatch")
    "g" '(magit-status :which-key "Magit status")
    "G" '(magit-status-here :which-key "Magit status here")
    "b" '(magit-branch-checkout :which-key "Checkout branch")
    "B" '(magit-blame-addition :which-key "Git blame")
    "l" '(magit-log :which-key "Log file history")))
#+END_SRC

Integration with Github is provided by the [[https://magit.vc][Forge]] package, which is an accompaniment to Magit.

NOTE: Make sure to [[https://magit.vc/manual/forge/Token-Creation.html#Token-Creation][configure a GitHub token]] before using this package!

#+BEGIN_SRC emacs-lisp
(use-package forge
  :after magit)
#+END_SRC

For browsing through a single file's history, use =git-timemachine=.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands git-timemachine git-timemachine-toggle
  :init
  (general-def
    :prefix "SPC g"
    :keymaps 'normal
    "t" '(git-timemachine-toggle :which-key "Browse file history")))
#+END_SRC

** Merging and diffing

Emacs provides =smerge= and [[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html#Top][ediff]] out of the box for dealing with version control conflict situations. We configure them here.

For =smerge=, the package itself is fine but the keybindings are awkward. Tweak them:

#+begin_src emacs-lisp
(use-package smerge-mode
  :ensure f
  :config
  (general-def
    :states 'normal
    :keymaps 'smerge-mode-map
    :major-modes t
    "[c" '(smerge-prev :which-key "Previous conflict")
    "]c" '(smerge-next :which-key "Next conflict"))
  (general-def
    :states 'normal
    :prefix "SPC g c"
    :keymaps 'smerge-mode-map
    :major-modes t
    "u" '(smerge-keep-upper :which-key "Keep upper")
    "l" '(smerge-keep-lower :which-key "Keep lower")
    "b" '(smerge-keep-base :which-key "Keep base")
    "a" '(smerge-keep-both :which-key "Keep all")))
#+end_src

Ediff has a little more configuration:

#+begin_src emacs-lisp
(use-package ediff
  :ensure t
  :init
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Projectile

We use [[https://docs.projectile.mx/projectile/index.html][Projectile]] to manage project configuration and navigation.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish projectile-mode
  :commands (projectile-project-root
             projectile-project-name
             projectile-project-p
             projectile-locate-dominating-file)
  :init
  (setq projectile-auto-discover nil)
  (setq projectile-enable-caching t)
  (setq projectile-globally-ignored-files '(".DS_Store" "TAGS"))
  (setq projectile-globally-ignored-file-suffixes '(".elc"))
  (setq projectile-kill-buffers-filter 'kill-only-files)
  (setq projectile-known-projects-file (concat user-emacs-directory "projectile.projects"))
  (setq projectile-ignored-projects '("~/"))
  :config
  (projectile-mode +1)
  (setq compilation-buffer-name-function #'projectile-compilation-buffer-name)
  (setq compilation-save-buffers-predicate #'projectile-current-project-buffer-p))
#+END_SRC

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :mode ("\\.yml\\'" "\\.yaml\\'"))
#+end_src

** Ruby and Rails

Set up the built-in Ruby mode.

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :defer t
  :hook (ruby-mode . subword-mode)
  :config
  (setq ruby-insert-encoding-magic-comment nil))
#+END_SRC

[[https://yardoc.org][Yard]] is a replacement for Rdoc for writing documentation. We want special Yard tags and keywords to be highlighted in comments.

#+BEGIN_SRC emacs-lisp
(use-package yard-mode
  :hook ruby-mode)
#+END_SRC

Inf-ruby can be used to quickly launch a Ruby REPL within Emacs that can be used to evaluate Ruby code.

#+BEGIN_SRC emacs-lisp
(use-package inf-ruby
  :init
  (setq inf-ruby-console-environment "development"))
#+END_SRC

[[https://rubocop.org][Rubocop]] provides linting and automatic formatting of Ruby code.

#+BEGIN_SRC emacs-lisp
(use-package rubocop
  :hook (ruby-mode . rubocop-mode)
  :config
  (general-def
    :states 'normal
    :prefix "SPC m f"
    :keymaps 'rubocop-mode-map
    :major-modes t
    "f" #'rubocop-check-current-file
    "F" #'rubocop-autocorrect-current-file
    "p" #'rubocop-check-project
    "P" #'rubocop-autocorrect-project))
#+END_SRC

[[https://github.com/dgutov/robe][Robe]] provides code navigation and navigation lookup.

#+BEGIN_SRC emacs-lisp
(use-package robe
  :hook (ruby-mode . robe-mode)
  :config
  (push 'company-robe company-backends)
  (general-def
    :states 'normal
    :prefix "SPC m"
    :keymaps 'robe-mode-map
    :major-mode t
    "'" #'robe-start
    "h" #'robe-doc)
  (general-def
    :states 'normal
    :prefix "SPC m i"
    :keymaps 'robe-mode-map
    :major-mode t
    "i" #'ruby-switch-to-inf
    "r" #'ruby-send-region))
#+END_SRC

[[https://bundler.io][Bundler]] has become indispensable in the Ruby world for managing dependencies. Especially in larger projects, when switching branches, it is often useful to be able to quickly install the latest dependencies using some keyboard shortcuts.

#+BEGIN_SRC emacs-lisp
(use-package bundler
  :commands (bundle-open
             bundle-console
             bundle-install
             bundle-update
             bundle-check)
  :config
  (general-def
    :states 'normal
    :prefix "SPC m b"
    :keymaps 'ruby-mode-map
    :major-modes t
    "c" #'bundle-check
    "C" #'bundle-console
    "i" #'bundle-install
    "u" #'bundle-update
    "e" #'bundle-exec
    "o" #'bundle-open))
#+END_SRC

Even though it is not as frequently used anymore as it once was, [[https://ruby.github.io/rake/][Rake]] is still an important part of the Ruby community and useful when working on non-Rails projects such as custom gems.

#+BEGIN_SRC emacs-lisp
(use-package rake
  :commands (rake
             rake-find-task
             rake-rerun)
  :init
  (setq rake-completion-system 'ivy)
  :config
  (general-def
    :states 'normal
    :prefix "SPC m k"
    :keymaps 'ruby-mode-map
    :major-modes t
    "k" #'rake
    "r" #'rake-rerun
    "R" #'rake-regenerate-cache
    "f" #'rake-find-task))
#+END_SRC

[[http://rspec.info][Rspec]] is my testing frawmework of choice for Ruby projects. It is key to be able to quickly run unit tests from my editor, navigate the results and re-run the previous tests after making some changes.

#+BEGIN_SRC emacs-lisp
(use-package rspec-mode
  :init
  (setq rspec-use-spring-when-possible nil)
  :config
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps '(rspec-verifiable-mode-map
               rspec-dired-mode-map
               rspec-mode-map)
    :major-modes t
    "a" #'rspec-verify-all
    "r" #'rspec-rerun)
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps '(rspec-verifiable-mode-map
               rspec-mode-map)
    :major-modes t
    "v" #'rspec-verify
    "c" #'rspec-verify-continue
    "l" #'rspec-run-last-failed)
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps 'rspec-verifiable-mode-map
    :major-modes t
    "f" #'rspec-verify-method
    "m" #'rspec-verify-matching)
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps 'rspec-mode-map
    :major-modes t
    "s" #'rspec-verify-single
    "e" #'rspec-toggle-example-pendingness)
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps 'rspec-dired-mode-map
    :major-modes t
    "v" #'rspec-dired-verify
    "s" #'rspec-dired-verify-single))
#+END_SRC

Sometimes, [[https://github.com/seattlerb/minitest][Minitest]] is just a better fit than Rspec.

#+BEGIN_SRC emacs-lisp
(use-package minitest
  :defer t
  :config
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps 'minitest-mode-map
    :major-modes t
    "r" #'minitest-rerun
    "a" #'minitest-verify-all
    "s" #'minitest-verify-single
    "v" #'minitest-verify))
#+END_SRC

For project navigation in Ruby on Rails projects, we use [[https://github.com/asok/projectile-rails][projectile-rails]], which provides us with many different keybindings for navigating to known parts in our project, such as controllers and models. All that is, of course, powered by Projectile and Ivy.

#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :hook ((ruby-mode
          inf-ruby-mode
          projectile-rails-server-mode
          web-mode) . projectile-rails-mode)
  :config
  (general-def
    :states 'normal
    :prefix "SPC m"
    :keymaps 'projectile-rails-mode-map
    :major-modes t
    "r" #'projectile-rails-command-map))
#+END_SRC

** Org mode

[[https://orgmode.org][Org mode]] is a productivity system, markup format and all-round killer app for Emacs. It comes pre-installed with Emacs, but we can further customize it to our liking, as well as add some additional tools.

First, we want to use the latest and greatest version of Org from its own package repository.

#+BEGIN_SRC emacs-lisp
(defun avdg/org-project-refile-targets ()
  "Lists all known project org files that can be used as refile targets."
  (seq-filter (lambda (p) (file-exists-p p))
              (append
               (mapcar (lambda (dir) (concat dir "todo.org")) projectile-known-projects)
               (mapcar (lambda (dir) (concat dir "notes.org")) projectile-known-projects))))

(use-package org
  :init
  (setq org-directory "~/org/")
  (setq org-ellipsis " ▾")
  (setq org-default-notes-file "~/org/inbox.org")
#+END_SRC

Refiling is moving subtrees from one note to another. We customize the targets where we can refile to to include project-specific org files, showing headings up to 3 levels deep.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((avdg/org-project-refile-targets :maxlevel . 3)
                             (nil :maxlevel . 3)))
  (setq org-refile-use-outline-path 'full-file-path)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

Some export-related tweaks, making HTML5-style exporting the default.

#+BEGIN_SRC emacs-lisp
  (setq org-html-doctype "html5")
  (setq org-html-html5-fancy t)
  (setq org-html-validation-link nil)
#+END_SRC

Other presentation and general tweaks:

#+BEGIN_SRC emacs-lisp
  (setq org-export-coding-system 'utf-8)
  (setq org-hide-emphasis-markers t)
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link t)
  (setq org-startup-indented t)
  (setq org-startup-numerated t)
  (setq org-num-max-level 3)
#+END_SRC

We customize our capture templates to allow for multiple ways of "quick entry". First, there are personal todo's and notes in =~/org/todo.org= and =~/org/notes.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
  '(("t" "Personal todo" entry
      (file+headline "todo.org" "Inbox")
      "* [ ] %?\n%i\n%a" :prepend t)
    ("t" "Personal notes" entry
      (file+headline "notes.org" "Inbox")
      "* %u %?\n%i\n%a" :prepend t)
#+END_SRC

For projects, we want to quickly capture entries in project-specific files. This provides for to-do's, notes and changelog entries.

#+BEGIN_SRC emacs-lisp
    ("p" "Project templates")
    ("pt" "Project todo" entry
      (file+headline (lambda () (concat projectile-project-root "todo.org")) "Inbox")
      "* [ ] %?\n%i\n%a" :prepend t)
    ("pn" "Project notes" entry
      (file+headline (lambda () (concat projectile-project-root "notes.org")) "Inbox")
      "* %U %?\n%i\n%a" :prepend t)
    ("pc" "Project changelog" entry
      (file+headline (lambda () (concat projectile-project-root "changelog.org")) "Inbox")
      "* %U %?\n%i\n%a" :prepend t)
#+END_SRC

Finally, for Org Roam we want to quickly capture new ideas in the inbox note so that we can further process them at a later time.

#+BEGIN_SRC emacs-lisp
    ("r" "Org Roam templates")
    ("ri" "Inbox idea" entry
      (file+headline (lambda () (concat org-roam-directory "20201118085217-inbox.org")) "Ideas")
      "* %U %?\n%i\n%a" :prepend t)
    ("rb" "Inbox book" entry
      (file+headline (lambda () (concat org-roam-directory "20201118085217-inbox.org")) "Books")
      "* %U %?\n%i\n%a" :prepend t)))
#+END_SRC

We put the org-related keybindings under the local leader prefix (~SPC m~).

#+BEGIN_SRC emacs-lisp
  (general-def
    :states 'normal
    :prefix "SPC m"
    :keymaps 'org-mode-map
    "e" '(org-export-dispatch :which-key "Export")
    "l ]" '(org-next-link :which-key "Next link")
    "l [" '(org-next-link :which-key "Previous link")
    "t t" '(org-todo :which-key "Toggle todo")
    "a" '(org-set-tags-command :which-key "Set tags")
    "b" '(org-insert-structure-template :which-key "Insert block")
    "r" '(org-refile :which-key "Refile"))
#+END_SRC

The "insert link" command is special because we also want it work in visual mode, not just in normal mode.

#+BEGIN_SRC emacs-lisp
  (general-def
    :states '(normal visual)
    :prefix "SPC m"
    :keymaps 'org-mode-map
    "l l" '(org-insert-link :which-key "Insert link")))
#+END_SRC

Then, some things to run when Org mode is loaded:

#+begin_src emacs-lisp
  :config
#+end_src

We want to be able to run languages using org-babel. We need to configure these explicitly:

#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (ruby . t)))
#+end_src

We set up some keybindings for working in large Org documents.

#+BEGIN_SRC emacs-lisp
  (general-def
    'normal
    "[h" 'org-previous-visible-heading
    "]h" 'org-next-visible-heading
    "[j" 'org-backward-heading-same-level
    "]j" 'org-forward-heading-same-level)
  (general-def
    :states 'normal
    :prefix "SPC m"
    :keymaps 'org-mode-map
    :major-modes t
    "g" #'counsel-org-goto
    "G" #'counsel-org-goto-all)
#+END_SRC

For working quickly with various kinds of Org mode blocks, we load =org-tempo= and define some custom shortcuts to quickly insert specific code blocks.

#+begin_src emacs-lisp
(use-package org-tempo
  :ensure f
  :after org
  :config
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("rb" . "src ruby"))
  (add-to-list 'org-structure-template-alist '("sql" . "src sql")))
#+end_src

*** Exporting

When exporting to HTML, we do want our source code blocks to be syntax highlighted. Org can do that for us if we have the =htmlize= package installed.

#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

In order to be able to export Org-mode buffers to many other formats we use Pandoc and ox-pandoc for direct Emacs integration.

#+begin_src emacs-lisp
(use-package ox-pandoc
  :after ox
  :init
  (add-to-list 'org-export-backends 'pandoc))
#+end_src

** Org-roam

To maintain a personal [[https://zettelkasten.de][Zettelkasten]] system we use [[https://www.orgroam.com][org-roam]].

#+BEGIN_SRC emacs-lisp
(use-package org-roam
  :commands (org-roam
             org-roam-find-file
             org-roam-jump-to-index
             org-roam-dailies-find-today
             org-roam-dailies-find-yesterday
             org-roam-dailies-capture-today
             org-roam-dailies-capture-yesterday
             org-roam-dailies-find-next-note
             org-roam-dailies-find-previous-note)
  :init
  (setq org-roam-directory (file-truename "~/org/roam/"))
#+END_SRC

We bind the keys for Roam under ~SPC n~ (for Notes).

#+BEGIN_SRC emacs-lisp
(general-def
  :states 'normal
  :prefix "SPC n"
  "n" '(org-roam :which-key "Toggle org-roam buffer")
  "f" '(org-roam-find-file :which-key "Find note")
  "i" '(org-roam-jump-to-index :which-key "Find index note")
  "t" '(org-roam-dailies-find-today :which-key "Find daily notes today")
  "y" '(org-roam-dailies-find-yesterday :which-key "Find daily notes yesterday")
  "T" '(org-roam-dailies-capture-today :which-key "Capture daily notes today")
  "Y" '(org-roam-dailies-capture-yesterday :which-key "Capture daily notes yesterday")
  "]" '(org-roam-dailies-find-next-note :which-key "Find daily notes next")
  "[" '(org-roam-dailies-find-previous-note :which-key "Find daily notes previous")))
#+END_SRC

To visualize the notes in a graph we use [[https://github.com/org-roam/org-roam-server][org-roam-server]].

#+BEGIN_SRC emacs-lisp
(use-package org-roam-server
  :commands org-roam-server-mode
  :init
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20))
#+END_SRC

** Focused writing mode

For a nicer writing experience we use writeroom-mode.

#+begin_src emacs-lisp
(use-package olivetti
  :commands olivetti-mode)
#+end_src

And for variable fonts we use mixed-pitch.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook (olivetti-mode . mixed-pitch-mode)
  :init
  (setq mixed-pitch-set-height t))
#+end_src

To make org-mode documents look even friendlier we use org-superstar which replaces org mode heading prefixes with fancy UTF-8 characters.

#+begin_src emacs-lisp
(use-package org-superstar
  :hook (org-mode . org-superstar-mode)
  :init
  (setq org-superstar-leading-bullet ?\s)
  (setq org-superstar-leading-fallback ?\s)
  (setq org-hide-leading-stars nil))
#+end_src

** Treemacs file explorer

Although Dired is fine for exploring files and operating on them, sometimes you want more of a sidebar-like tree view of a project. That's what [[https://github.com/Alexander-Miller/treemacs][Treemacs]] provides.

#+begin_src emacs-lisp
(use-package treemacs
  :commands treemacs treemacs-select-window
  :init
  (setq treemacs-follow-after-init t)
  (setq treemacs-is-never-other-window t)
  (setq treemacs-sorting 'alphabetic-case-insensitive-asc)
  (general-def
    :prefix "SPC o"
    :keymaps 'normal
    "t" '(treemacs :which-key "Toggle treemacs")
    "T" '(treemacs-find-file :which-key "Find file in treemacs"))
  (global-set-key (kbd "s-!") 'treemacs-select-window))
#+END_SRC

Treemacs provides some extra integration options so we use packages to combine it with Evil, Projectile and Magit.

#+BEGIN_SRC emacs-lisp
(use-package treemacs-evil
  :after treemacs evil)
(use-package treemacs-projectile
  :after treemacs projectile)
(use-package treemacs-magit
  :after treemacs magit)
#+end_src

** Web mode

[[https://web-mode.org][Web-mode]] is a great package for dealing with HTML and CSS files.

#+begin_src emacs-lisp
(use-package web-mode
  :mode (("\\.html\\'" . web-mode)
      ("\\.erb\\'" . web-mode)
      ("\\.eex\\'" . web-mode)
      ("\\.mustache\\'" . web-mode))
  :init
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+end_src

Writing HTML can be a pain so we also add [[https://emmet.io][Emmet]] support with [[https://github.com/smihica/emmet-mode][emmet-mode]].

#+begin_src emacs-lisp
(use-package emmet-mode
  :after web-mode
  :init
  (setq emmet-self-closing-tag-style "")
  :hook ((web-mode sgml-mode html-mode) . emmet-mode))
#+end_src

** Javascript

There is no getting around javascript.

#+begin_src emacs-lisp
(use-package js2-mode
  :mode (("\\.js\\'" . js2-mode)
         ("\\.jsx\\'" . js2-jsx-mode))
  :interpreter (("node" . js2-node)
                ("node" . js2-jsx-mode)))
#+end_src

We can at least make it look pretty using prettier.

#+begin_src emacs-lisp
(use-package prettier-js
  :hook ((js2-mode js-mode web-mode) . prettier-js-mode))
#+end_src

** Typescript

Set up configuration for editing Typescript files. Note that in order for LSP integration to work, you will need to set up a language server. For example:

#+begin_src shell
npm install -g typescript-language-server typescript
#+end_src

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\\.ts\\'"
  :hook (typescript-mode . lsp-deferred)
  :init
  (setq typescript-indent-level 2))
#+end_src

** Elm

Set up configuration for Elm files and integration with Flycheck.

#+begin_src emacs-lisp
(use-package elm-mode
  :hook ((elm-mode . elm-format-on-save-mode)
         (elm-mode . lsp-deferred))
  :init
  (setq elm-sort-imports-on-save t)
  :config
  (add-to-list 'company-backends 'elm-company))

(use-package flycheck-elm
  :after elm-mode
  :config
  (add-to-list 'flycheck-checkers 'elm))
#+end_src

** Elixir

Set up configuration for Elixir projects and Flycheck integration. We apply auto-formatting on save and use Ruby's mode for automatically inserting ~end~ after ~do~.

#+begin_src emacs-lisp
(use-package elixir-mode
  :hook ((elixir-mode . lsp-deferred)
         (elixir-mode . subword-mode))
  :init
  (add-hook 'elixir-mode-hook
            (lambda () (add-hook 'before-save-hook 'elixir-format nil t))))
#+end_src

Further integration with Mix, the build tool for elixir, is provided by [[https://github.com/ayrat555/mix.el][Mix.el]]:

#+begin_src emacs-lisp
(use-package mix
  :hook (elixir-mode . mix-minor-mode)
  :init
  (setq compilation-scroll-output t))
#+end_src

Alchemist provides rich project navigation and integration for Elixir and Phoenix projects.

#+begin_src emacs-lisp
(use-package alchemist
  :hook (elixir-mode . alchemist-mode))
#+end_src

ExUnit is the testing framework of choice in Elixir.

#+begin_src emacs-lisp
(use-package exunit
  :hook (elixir-mode . exunit-mode)
  :init
  (general-def
    :states 'normal
    :prefix "SPC m t"
    :keymaps '(elixir-mode-map exunit-mode-map)
    :major-modes t
    "a" #'exunit-verify-all
    "r" #'exunit-rerun
    "v" #'exunit-verify
    "T" #'exunit-toggle-file-and-test
    "t" #'exunit-toggle-file-and-test-other-window
    "s" #'exunit-verify-single))
#+end_src

[[https://github.com/rrrene/credo/][Credo]] is a code linter and style checker for Elixir code.  Use flycheck-credo to integrate credo with Flycheck.

#+begin_src emacs-lisp
(use-package flycheck-credo
  :after flycheck-credo
  :config
  (flycheck-credo-setup))
#+end_src

** SQL

Although Emacs provides SQL editing support out of the box, we can do slightly better. We use [[https://github.com/purcell/sqlformat][sqlformat]] to provide auto-formatting using =pg_format=. Note that this requires to have =pg_format= installed, for example like so on Mac OS:

#+begin_src shell
brew install pgformatter
#+end_src

#+begin_src emacs-lisp
(use-package sqlformat
  :commands (sqlformat sqlformat-buffer sqlformat-region)
  :hook (sql-mode . sqlformat-on-save-mode)
  :init
  (setq sqlformat-command 'pgformatter)
  (setq sqlformat-args '("-s2" "-g" "-u1"))
  (general-def
    :states 'normal
    :prefix "SPC m"
    :keymaps 'sql-mode-map
    :major-modes t
    "f" '(sqlformat-buffer :which-key "Format buffer")))
#+end_src

** Restclient

You can work with HTTP requests from Emacs using [[https://github.com/pashky/restclient.el][Restclient]], instead of using external tools like Postman or Insomnia.

#+begin_src emacs-lisp
(use-package restclient
  :mode "\\.http\\'")
#+end_src

Using [[https://github.com/alf/ob-restclient.el][ob-restclient]] we can even integrate Restclient into Org mode so we use it in literate programming using org-babel.

#+begin_src emacs-lisp
(use-package ob-restclient
  :after restclient
  :init
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((restclient . t))))
#+end_src

** Custom functions

I copied this function from [[https://emacsredux.com/blog/2013/05/04/rename-file-and-buffer/][Emacs Redux]] to allow me to rename a buffer and the file it is visiting.

#+begin_src emacs-lisp
(defun avdg/rename-file-and-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (set-visited-file-name new-name t t)))))))

(general-def
  :prefix "SPC f"
  :keymaps 'normal
  "R" '(avdg/rename-file-and-buffer :which-key "Rename file and buffer"))
#+end_src

Likewise, a function to remove a file and its buffer (also [[https://emacsredux.com/blog/2013/04/03/delete-file-and-buffer/][found on Emacs Redux]]):

#+begin_src emacs-lisp
(defun avdg/delete-file-and-buffer ()
  "Kill the current buffer and deletes the file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (if (vc-backend filename)
          (vc-delete-file filename)
        (progn
          (delete-file filename)
          (message "Deleted file %s" filename)
          (kill-buffer))))))

(general-def
  :prefix "SPC f"
  :keymaps 'normal
  "D" '(avdg/delete-file-and-buffer :which-key "Delete file and buffer"))
#+end_src

And a function to copy the path to the currently visited file to the clipboard (also found [[https://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/][on Emacs Redux]]):

#+begin_src emacs-lisp
(defun avdg/copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(general-def
  :prefix "SPC f"
  :keymaps 'normal
  "y" '(avdg/copy-file-name-to-clipboard :which-key "Copy filename"))
#+end_src

* Wrap up

Print a message with timing information so we have some idea how long it took to start up Emacs, and whether it is time to optimise some things.

#+BEGIN_SRC emacs-lisp
(message "[avdg] Finished loading in %.2fms"
    (* 1000.0
      (float-time (time-subtract after-init-time before-init-time))))
#+END_SRC
